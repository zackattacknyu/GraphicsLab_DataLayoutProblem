//Data structure
 
Access requirement:
-        Doubly-linked list AR: head, tail
-        AR node: ID, position, prev, next
 
Data unit entity: ID, position, list of ARs use it
 
position findMincut (position1, position2)
	/*For the following line, we will use a centered interval tree:
		http://en.wikipedia.org/wiki/Interval_tree#Centered_interval_tree
	The time required for each query will be O(log n + n) with n=# of AR
	Total time will thus be O(log n* N_0 + n*N_0) with N being the number of data units.
	
	Another idea:
	Make an integer array and for each position, put number of overlapping ARs
	Finding the min will thus just take O(n) time
	
	Find out about the use of a graph here, as it does not seem necessary. 
		Also, this is not a proper min cut as a cut of the graph would not 
				necessary satisfy what we need.
	*/
	return position with the minimum number of cuts
 
//Main algorithm
for each Acesss Requirement P
//first analyze head node
	//group adjacent units
	length = 0
	start = P.head
	end = P.head.next
	while end.position – start.position = 1 //seems to measure number of adjacent units
		length = length + 1
		start = start.next
		end = end.next
	potential = P.head.next.position – P.head.position - length //seek time to be saved for this AR
	destination = findMincut(P.head.next.position, P.tail.position)
	benefit = potential
	//calculate cost to other ARs
	for each other AR uses head to head + length, T
		if P.head is T.head
			//what gets updated here?
			benefit + min(potential, T.head.next.position – T.head.position - length)
			chooseNewCopy
		if P.head + length is T.tail
			chooseOldCopy
		if P.head NOT T.head AND P.head NOT T.tail
			//decide which copy to use in T
			if P.head is T.head.next
			{
				difference1 = end.position – start.position
				if destination > T.tail.prev.position
					difference2 = Destination + length - T.tail.prev.position
				else
					difference2 = 0
			}
			if difference1 > difference2
				chooseNewCopy
			else
				chooseOldCopy
	if no one chooseOldCopy
		discard P.head
		for each AR, A
			if A.head.position < P.head.postion AND A.tail.position > start.postion
						//what is getting updated here?
						benefit + length
	//add info to priority queue?
	enQueue(P.head, length, destination, benefit)
 
//Execution
(Node, length, destination) <- deQueue
Copy Node up to length to destination
Update links for all Ts chooseNewCopy
Update benefit for all Ps cover destination up to length
If Node is discard
	Update benefit for all Ps cover Node up to length
Reform Heap

